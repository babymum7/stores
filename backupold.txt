ReviewSchema.pre('find', function() {
  this.populate('author', 'name email avatar');
});


ReviewSchema.virtual('rating').get(function() {
  const document = this;
  if (document.author.rates.length) {
    const rate = document.author.rates.find(e => e.store.toString() === document.store.toString());
    if (rate) return rate.rating;
  }
});


StoreSchema.virtual('reviews', {
  ref: 'Review',
  localField: '_id',
  foreignField: 'store',
  options: { sort: { name: -1 }, limit: 10 }
});

StoreSchema.statics.getReviews = function(Review, storeId) {
  const id = mongoose.Types.ObjectId(storeId);
  return Review.find({ store: id })
    .sort({ created: -1 })
    .limit(10);
};

StoreSchema.statics.getScore = function(slugName) {
  return this.aggregate([
    { $match: { slug: slugName } },
    { $lookup: { from: 'users', localField: 'author', foreignField: '_id', as: 'author' } },
    { $lookup: { from: 'rates', localField: '_id', foreignField: 'store', as: 'rates' } },
    {
      $lookup: {
        from: 'reviews',
        let: { storeId: '$_id', rates: '$rates' },
        pipeline: [
          { $match: { $expr: { $eq: ['$store', '$$storeId'] } } },
          { $lookup: { from: 'users', localField: 'author', foreignField: '_id', as: 'author' } },
          { $addFields: { author: { $arrayElemAt: ['$author', 0] } } },
          {
            $project: {
              'author.name': 1,
              'author.avatar': 1,
              created: 1,
              text: 1,
              'author.rating': {
                $let: {
                  vars: { index: { $indexOfArray: ['$$rates.user', '$author._id'] } },
                  in: { $cond: [{ $lt: ['$$index', 0] }, null, { $arrayElemAt: ['$$rates.rating', '$$index'] }] }
                }
              }
            }
          },
          { $sort: { created: -1 } },
          { $limit: 10 }
        ],
        as: 'reviews'
      }
    },
    {
      $addFields: {
        author: { $arrayElemAt: ['$author', 0] },
        averageRate: { $avg: '$rates.rating' },
        totalRate: { $sum: '$rates.rating' }
      }
    },
    {
      $project: {
        'author.name': 1,
        totalRate: 1,
        averageRate: 1,
        reviews: 1,
        photo: 1,
        location: 1,
        description: 1,
        tags: 1,
        name: 1,
        slug: 1
      }
    }
  ]);
};

UserSchema.virtual('gravatar').get(function() {
  const hash = md5(this.email);
  return `https://gravatar.com/avatar/${hash}?s=200&d=retro`;
});


Store.mapReduce({ map: mapAdd, reduce, out: { replace: 'words' } }).catch(err => console.log(err.message));

StoreSchema.post('save', extractWords);

async function extractWords() {
  try {
    await this.constructor.mapReduce({
      map: mapAdd,
      reduce,
      out: { reduce: 'words' },
      query: { _id: this._id }
    });
  } catch (err) {
    console.log(err.message);
  }
}

StoreSchema.statics.subtracttWords = function(id) {
  const objectId = mongoose.Types.ObjectId(id);
  return this.mapReduce({
    map: mapMinus,
    reduce,
    out: { reduce: 'words' },
    query: { _id: objectId }
  });
};

const Review = require('./Review');

exports.searchStores = async (req, res) => {
  const { q } = req.query;
  const previousWords = q.slice(0, q.lastIndexOf(' ') + 1);
  const currentWord = q.slice(q.lastIndexOf(' ') + 1);
  const words = await Word.find({
    _id: { $regex: `^${currentWord}`, $options: 'i' }
  });
  const query = previousWords.concat(words.map(word => word._id).join(' '));
  const stores = await Store.find(
    { $text: { $search: query, $caseSensitive: false } },
    {
      score: { $meta: 'textScore' },
      name: 1,
      slug: 1,
      _id: 0
    }
  )
    .sort({ score: { $meta: 'textScore' } })
    .limit(7);
  res.json(stores);
};

const multerOptions = {
  storage: multer.memoryStorage()
  fileFilter(req, file, done) {
    const isPhoto = file.mimetype.startsWith('image/');
    if (isPhoto) {
      done(null, true);
    } else {
      done(null, false);
    }
  }
};

StoreSchema.statics.getTopStores = function() {
  return this.aggregate([
    {
      $lookup: {
        from: 'users',
        let: { storeId: '$_id' },
        pipeline: [
          { $unwind: '$rates' },
          { $match: { $expr: { $eq: ['$rates.store', '$$storeId'] } } },
          { $project: { 'rates.rating': 1, _id: 0 } }
        ],
        as: 'rates'
      }
    },
    {
      $lookup: {
        from: 'reviews',
        localField: '_id',
        foreignField: 'store',
        as: 'reviews'
      }
    },
    {
      $match: {
        $and: [{ 'reviews.1': { $exists: true } }, { rates: { $ne: [] } }]
      }
    },
    {
      $project: {
        photo: 1,
        name: 1,
        slug: 1,
        reviews: { $size: '$reviews' },
        totalStars: { $sum: '$rates.rates.rating' },
        averageRating: { $avg: '$rates.rates.rating' },
        _id: 0
      }
    },
    { $sort: { totalStars: -1 } },
    { $limit: 10 }
  ]);
};

StoreSchema.statics.getCoorTopStore = function(User) {
  return User.aggregate([
    { $unwind: '$rates' },
    { $group: { _id: '$rates.store', totalStar: { $sum: '$rates.rating' } } },
    { $sort: { totalStar: -1 } },
    { $limit: 1 },
    {
      $lookup: {
        from: 'stores',
        localField: '_id',
        foreignField: '_id',
        as: 'store'
      }
    },
    { $project: { 'store.location.coordinates': 1, _id: 0 } }
  ]);
};

// prettier-ignore
exports.mapAdd = function() {
  const document = this;
  const haveFields = ['name', 'description', 'tags'];
  const keys = Object.keys(document).filter(key => haveFields.includes(key));
  /* eslint-disable */
  /* prettier-ignore */
  const emitWords = string => string
    .replace(/[^\w\s]/gi, '')
    .toLowerCase()
    .trim()
    .split(' ')
    .forEach(word => emit(word, 1));
  /* eslint-enable */
  keys.forEach(key => {
    if (Array.isArray(document[key])) {
      document[key].forEach(element => emitWords(element));
    } else {
      emitWords(document[key]);
    }
  });
};

exports.mapMinus = function() {
  const document = this;
  const haveFields = ['name', 'description', 'tags'];
  const keys = Object.keys(document).filter(key => haveFields.includes(key));
  /* eslint-disable */
  /* prettier-ignore */
  const emitWords = string => string
    .replace(/[^\w\s]/gi, '')
    .toLowerCase()
    .trim()
    .split(' ')
    .forEach(word => emit(word, -1));
  /* eslint-enable */
  keys.forEach(key => {
    if (Array.isArray(document[key])) {
      document[key].forEach(element => emitWords(element));
    } else {
      emitWords(document[key]);
    }
  });
};

exports.reduce = function(key, values) {
  /* eslint-disable */
  return values.reduce((result, e) => (result += e), 0);
  /* eslint-enable */
};

// prettier-ignore
exports.mapAdd = function() {
  const document = this;
  const haveFields = ['name', 'description', 'tags'];
  const keys = Object.keys(document).filter(key => haveFields.includes(key));
  /* eslint-disable */
  /* prettier-ignore */
  const emitWords = string => string
    .replace(/[^\w\s]/gi, '')
    .toLowerCase()
    .trim()
    .split(' ')
    .forEach(word => emit(word, 1));
  /* eslint-enable */
  keys.forEach(key => {
    if (Array.isArray(document[key])) {
      document[key].forEach(element => emitWords(element));
    } else {
      emitWords(document[key]);
    }
  });
};

exports.mapMinus = function() {
  const document = this;
  const haveFields = ['name', 'description', 'tags'];
  const keys = Object.keys(document).filter(key => haveFields.includes(key));
  /* eslint-disable */
  /* prettier-ignore */
  const emitWords = string => string
    .replace(/[^\w\s]/gi, '')
    .toLowerCase()
    .trim()
    .split(' ')
    .forEach(word => emit(word, -1));
  /* eslint-enable */
  keys.forEach(key => {
    if (Array.isArray(document[key])) {
      document[key].forEach(element => emitWords(element));
    } else {
      emitWords(document[key]);
    }
  });
};

exports.reduce = function(key, values) {
  /* eslint-disable */
  return values.reduce((result, e) => (result += e), 0);
  /* eslint-enable */
};

